{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emerald Source Code Commentary by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original commercial source code. This is a courtesy notice to anyone obligated to maintain a clean-room status. Introduction Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit. Decompiliation It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's... unauthorized, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: some of the functionality is unlocalized, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, the way in-game text is represented is a nightmare and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Tools) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Introduction"},{"location":"#emerald-source-code-commentary","text":"by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original commercial source code. This is a courtesy notice to anyone obligated to maintain a clean-room status.","title":"Emerald Source Code Commentary"},{"location":"#introduction","text":"Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit.","title":"Introduction"},{"location":"#decompiliation","text":"It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's... unauthorized, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: some of the functionality is unlocalized, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, the way in-game text is represented is a nightmare and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Tools) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Decompiliation"},{"location":"about/","text":"About The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"about/#about","text":"The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"initmain/","text":"Init and Main Everyone who has programmed in C/C++ or even been tangentially exposed to it knows about main \u2013 the special name reserved for the function that will first run when the program begins. This is, of course, perched on a throne of lies; it's not the first to run, it's just the first to run after some boring housekeeping stuff that is essentially identical in every program on a given platform and generally inserted automatically by the compiler. Of course, we are insisting on running bare-metal on a tiny toy for children and so we get to manually include our own pre- main initialization steps. As mentioned previously, the ROM header contains the first instruction of the game at 0x08000000 , which we can see is b Init , where b (ranch) is equivalent to goto . The Init function is located in crt0.s which is simply a conventionalized name for the code that initializes the C runtime. It is written in assembly because it needs to interface directly with the specific hardware at hand in a way that cannot be expressed at the C abstraction level. If you want to look up more about any of the opcodes, keep in mind that the GBA is a 32-bit ARM architecture with THUMB support, not an x86 one. Note 32-bit ARM processors can run in two distinct modes, dubbed ARM and THUMB, and switch between them on a function-by-function basis. ARM opcodes are four bytes each and THUMB opcodes are two bytes each, and hence can encode less information per operation but in many cases will make the function much smaller overall for the purposes of reducing ROM size. The switching modes is done with a clever trick: since opcodes are always aligned in memory (starting on a multiple of 4 or 2 depending on their size), there's no such thing as an instruction that starts at an odd address. Hence, the smallest bit of an address can be used as a flag to indicate THUMB mode. If the CPU attempts to branch to an odd-numbered address, it switches to THUMB mode and subtracts one from the address before branching. When it branches to an even one, it switches to ARM mode. crt0.s Init:: mov r0, #PSR_IRQ_MODE msr cpsr_cf, r0 ldr sp, sp_irq mov r0, #PSR_SYS_MODE msr cpsr_cf, r0 ldr sp, sp_sys ldr r1, =INTR_VECTOR adr r0, IntrMain str r0, [r1] .if MODERN mov r0, #255 @ RESET_ALL svc #1 << 16 .endif @ MODERN ldr r1, =AgbMain + 1 mov lr, pc bx r1 b Init Do not panic if this is completely incomprehensible. The vast majority of the game is written in C. This code relies heavily on writing magic numbers to magic registers that can only be understood with manufacturer documentation. It first initializes the IRQ (interrupt request) stack at the very end of fast RAM, reserving a small amount of space for the hardware to store information about events the game will want to process. It then initializes the system stack for the arguments of functions, also in fast RAM (IWRAM). Within a specific slot of the IRQ stack we just set up, specifically INTR_VECTOR == 0x3007FFC , we store the address of the function IntrMain so it can be called to process interrupts. The .if MODERN brackets our first optional deviation from the original game, although it's just moving the operation from immediately after AgbMain begins to immediately before it to keep compilers happy. The svc or supervisor call instruction is an alternate name for the swi or software interrupt instruction which will call into the utility functions stored in the BIOS. Due to Reasons, the index number of the requested interrupt needs to be different depending on whether the CPU is currently in ARM or THUMB mode. Since we are in ARM mode, we need to take the index we want and shift it by 16. BIOS function #1 is RegisterRamReset (reminder: documentation ) and we are calling it with an argument of RESET_ALL , meaning all registers and RAM (except for a small carve-out for the IRQ area, which it knows to leave alone) will be set to a clean state of 0. While a game may seem to work fine without doing this, it is a very good idea to always reset memory to a known state. On real hardware, the RAM and registers will power on with random values due to electrical noise. This can lead to random bugs that cannot be reproduced at will. (Emulators usually clean the pretend RAM and registers before emulation begins, but they are not required to do so.) Note A real-world example of a bug introduced by not clearing RAM can see seen in Super Mario All-Stars . If a certain byte in RAM happened to randomly settle to 0x80 when the Super Nintendo was powered on, the game would mistakenly believe it was a developer system and enable debug mode. Since this randomization is determined by the physical environment, some Super Nintendos were more prone to initializing in that exact way than others, and hence some people seemingly had a \"debug copy\" of the game. Finally, the address of AGBMain is loaded (consult the note above on THUMB for why we add 1) and called. If AGBMain ever returns (it shouldn't!) then the last instruction of Init will loop back to the first. Otherwise, since there is no other layer underneath to return to, execution would simply proceed to whatever happened to be next in memory \u2013 which in this case is some constants referenced by Init which aren't meant to be executed as instructions. IntrMain , which was installed by Init as the interrupt handler, mostly consists of an if-cascade that checks for each interrupt flag one at a time, incrementing an index in r12 as it goes. The bit that actually makes things happen is small: ldr r1, =gIntrTable add r1, r1, r12 ldr r0, [r1] stmfd sp!, {lr} adr lr, IntrMain_RetAddr bx r0 This simply indexes into gIntrTable , which will be set up later, and calls whatever function it finds there. Note that interrupts are not yet enabled as of the moment we are stepping into AgbMain and hence there's no danger of IntrMain being called before the table is filled out. That's it \u2013 that's every bit of secret pre- main initialization starting from the cartridge's first instruction. We may now progress to the master game loop. main.c Just as a curiosity, we can see the exact moment that the final build of the English edition of Emerald was compiled: const char BuildDateTime[] = \"2005 02 21 11:10\"; Note that's a few months before the game went on sale; physical cartridges have a lot of lead time. Clearly, this time stamp was patched in by the build tools rather than manually typed into the original source code. (Specifically, a header file containing nothing but the current timestamp was generated at each compile time by the Makefile.) It's preserved here exactly as it was so that the ROM can be recompiled back to the same state. Another curiosity is that the leaked source dump has a timestamp of \"2005 06 14 15:20\" , so it appears to be a backup made while preparing the European release that launched in October. The final Spanish ROM's timestamp is two weeks later: \"2005 07 01 18:30\" . (Almost all such leaks come from third party localizers who needed the ability to edit the source code directly. The disks they were mailed kick around in someone's garage until someone else who never signed a contract with the publisher finds them.) In IntrMain we saw an interrupt table which had not yet been initialized. Its default state is encoded here, with many of the entries set to a dummy placeholder as the game does not actually care about them: const IntrFunc gIntrTableTemplate[] = { VCountIntr, // V-count interrupt SerialIntr, // Serial interrupt Timer3Intr, // Timer 3 interrupt HBlankIntr, // H-blank interrupt VBlankIntr, // V-blank interrupt IntrDummy, // Timer 0 interrupt IntrDummy, // Timer 1 interrupt IntrDummy, // Timer 2 interrupt IntrDummy, // DMA 0 interrupt IntrDummy, // DMA 1 interrupt IntrDummy, // DMA 2 interrupt IntrDummy, // DMA 3 interrupt IntrDummy, // Key interrupt IntrDummy, // Game Pak interrupt }; Note HBlank and VBlank are terms dating from the CRT television era. The pixels of the screen are updated left-to-right and top-to-bottom each frame. The horizontal blank interrupt activates each time the end of a row of pixels is reached (hence 160x per frame) and the vertical blank interrupt activates each time the end of rendering is reached and the screen will return to the first pixel in the upper left (hence definitionally once per frame, very slightly faster than 60x per second). This lets the game know when it's time to update the visuals that will be rendered to the screen. It is the responsibility of the programmer to keep the handlers for these interrupts as short as possible; it would be very bad if VBlank activated while only halfway through processing the previous VBlank! Next are a messy set of miscellaneous globals for tracking game state: static u16 sUnusedVar; // Never read u16 gKeyRepeatStartDelay; bool8 gLinkTransferringData; struct Main gMain; u16 gKeyRepeatContinueDelay; bool8 gSoftResetDisabled; IntrFunc gIntrTable[INTR_COUNT]; u8 gLinkVSyncDisabled; u32 IntrMain_Buffer[0x200]; s8 gPcmDmaCounter; static EWRAM_DATA u16 sTrainerId = 0; The one marked unused is named mssize in the original code and is set to the sizeof() of a structure used for multiplayer on the serial cable. It's presumably vestigial from early scaffolding. The gMain structure is defined in main.h and bundles together several things that are constantly relevant in every phase of the game: struct Main { /*0x000*/ MainCallback callback1; /*0x004*/ MainCallback callback2; /*0x008*/ MainCallback savedCallback; /*0x00C*/ IntrCallback vblankCallback; /*0x010*/ IntrCallback hblankCallback; /*0x014*/ IntrCallback vcountCallback; /*0x018*/ IntrCallback serialCallback; /*0x01C*/ vu16 intrCheck; /*0x020*/ u32 vblankCounter1; /*0x024*/ u32 vblankCounter2; /*0x028*/ u16 heldKeysRaw; // held keys without L=A remapping /*0x02A*/ u16 newKeysRaw; // newly pressed keys without L=A remapping /*0x02C*/ u16 heldKeys; // held keys with L=A remapping /*0x02E*/ u16 newKeys; // newly pressed keys with L=A remapping /*0x030*/ u16 newAndRepeatedKeys; // newly pressed keys plus key repeat /*0x032*/ u16 keyRepeatCounter; // counts down to 0, triggering key repeat /*0x034*/ bool16 watchedKeysPressed; // whether one of the watched keys was pressed /*0x036*/ u16 watchedKeysMask; // bit mask for watched keys /*0x038*/ struct OamData oamBuffer[128]; /*0x438*/ u8 state; /*0x439*/ u8 oamLoadDisabled:1; /*0x439*/ u8 inBattle:1; /*0x439*/ u8 anyLinkBattlerHasFrontierPass:1; }; Zoom. Enhance. u8 state; This is a load-bearing byte. gMain.state is the master state machine tracker value. It's updated in over 500 locations across several dozen source files. Each distinct type of screen (title screen, evolution screen, etc) uses it to keep track of where it is in its sequence of possible events. The meaning of each possible value is specific to each screen. In a hypothetically perfect engine each game mode should track its state independently, but memory is tight and it's not possible for more than one to be running concurrently. The actual main function is pretty concise, and on a first reading you will almost certainly miss where the actual game happens: void AgbMain() { // Modern compilers are liberal with the stack on entry to this function, // so RegisterRamReset may crash if it resets IWRAM. #if !MODERN RegisterRamReset(RESET_ALL); #endif //MODERN *(vu16 *)BG_PLTT = RGB_WHITE; // Set the backdrop to white on startup InitGpuRegManager(); REG_WAITCNT = WAITCNT_PREFETCH_ENABLE | WAITCNT_WS0_S_1 | WAITCNT_WS0_N_3; InitKeys(); InitIntrHandlers(); m4aSoundInit(); EnableVCountIntrAtLine150(); InitRFU(); RtcInit(); CheckForFlashMemory(); InitMainCallbacks(); InitMapMusic(); #ifdef BUGFIX SeedRngWithRtc(); // see comment at SeedRngWithRtc definition below #endif ClearDma3Requests(); ResetBgs(); SetDefaultFontsPointer(); InitHeap(gHeap, HEAP_SIZE); gSoftResetDisabled = FALSE; if (gFlashMemoryPresent != TRUE) SetMainCallback2(NULL); gLinkTransferringData = FALSE; sUnusedVar = 0xFC0; #ifndef NDEBUG #if (LOG_HANDLER == LOG_HANDLER_MGBA_PRINT) (void) MgbaOpen(); #elif (LOG_HANDLER == LOG_HANDLER_AGB_PRINT) AGBPrintfInit(); #endif #endif for (;;) { ReadKeys(); if (gSoftResetDisabled == FALSE && JOY_HELD_RAW(A_BUTTON) && JOY_HELD_RAW(B_START_SELECT) == B_START_SELECT) { rfu_REQ_stopMode(); rfu_waitREQComplete(); DoSoftReset(); } if (Overworld_SendKeysToLinkIsRunning() == TRUE) { gLinkTransferringData = TRUE; UpdateLinkAndCallCallbacks(); gLinkTransferringData = FALSE; } else { gLinkTransferringData = FALSE; UpdateLinkAndCallCallbacks(); if (Overworld_RecvKeysFromLinkIsRunning() == TRUE) { gMain.newKeys = 0; ClearSpriteCopyRequests(); gLinkTransferringData = TRUE; UpdateLinkAndCallCallbacks(); gLinkTransferringData = FALSE; } } PlayTimeCounter_Update(); MapMusicMain(); WaitForVBlank(); } } Did you spot it? The game happens inside UpdateLinkAndCallCallbacks() . A callback is when a function's address is stored in a variable by one piece of code so that another piece of code will later call it without necessarily knowing or caring exactly what it will do. Various pieces of game logic will stash functions in the callback variables (we saw them in the gMain struct) for AgbMain to call on its next loop and keep the game moving. The very first callbacks are initialized in the helper function InitMainCallbacks() \u2013 technically only one is set, CB2_InitCopyrightScreenAfterBootup() . We will check it out later. If you browse the various helper functions called in the initialization stage of the main function, you will see something that is traditionally a no-no in application programming \u2013 writing directly to a specific hard-coded address: void StartTimer1(void) { REG_TM1CNT_H = 0x80; } (Where REG_TM1CNT_H == 0x04000106 after chasing it down through multiple layers of defines.) When working directly with the real, unprotected memory space of a device, it is typical for specific addresses to be physically wired to hardware components for the purpose of interacting with them. These addresses are unique to every kind of device and must be looked up in documentation . This address is connected to \"Timer 1 Control\", and by setting it to 0x80 (better understood as 0b10000000 since it is a set of bit flags) the timer is enabled and starts ticking. There's actually a very serious bug in AgbMain() , one which has a huge impact on advanced gameplay such as speedrunning and shiny hunting: they forgot to seed the RNG. They straight-up forgot! In Ruby/Sapphire, there is a call to SeedRngWithRtc() following InitMapMusic() : static void SeedRngWithRtc(void) { u32 seed = RtcGetMinuteCount(); seed = (seed >> 16) ^ (seed & 0xFFFF); SeedRng(seed); } This means there are thousands of different RNG streams from power-on depending on what value was pulled from the real-time clock, which keeps running when the game is off. This code was removed for Fire Red/Leaf Green as these were ports of older games with no RTC. When they sat down to hack together Emerald, it seems the team used the version of AgbMain they had made for FRLG rather than RS. They forgot to restore the RNG initialization, and so now every legitimate copy of Emerald is stuck booting with an RNG value of 0x0000 . The PRET decompiliation will include SeedRngWithRtc() at the correct place if BUGFIX compile mode is enabled, which allows you to experience an alternate reality where randomness is slightly more actually random. This is a classic Game Freak bug: understandable how it happened, but a solid gameplay testing process should have caught it. Note RNG (random number generation) can only be \"truly\" random if it is reading from a physical random process such as radioactive decay. Algorithms that can run quickly on something like a Game Boy Advance are a very rough approximation, and require a kick-off random number, the \"seed\", so that they do not simply produce the same sequence each time the game is run. While a linearly increasing clock is not very random at all, the exact value at whatever time you happen to turn on the game might as well be for basic seeding purposes. The seed being stuck at zero after every reboot in Emerald means that the exact same series of player inputs will always result in the same series of events such as wild encounters, critical hits, capture successes, and what stats are assigned to newly captured mons. Fortunately, normal players are divergent enough in their inputs that the broken RNG is not too wildly obvious. (Shiny hunters are Not Normal.) There is another bug just in the functions called directly from AgbMain : if the option is set to treat the \"L\" button as equivalent to the \"A\" button, ReadKeys() won't correctly do key repeat for the \"L\" as an \"A\". Another bug that should have been found in testing, and this one is an original sin of Ruby/Sapphire. Ignoring complications introduced by whether or not the link cable is active, the structure of the infinite game loop is straightforward: Check which buttons are pressed on the controller; Check whether it's time to do a soft reset; Call the currently registered callbacks, which contain the game logic; Update how long the game has been running; Do some bookkeeping with the music; Wait for the end of the VBlank interrupt which signals the end of the frame. The last step keeps everything synchronized by ensuring everything happens once per 60th of a second. If too much work is done in a callback to meet the frame deadline, it can cause audio-visual issues. The last thing we'll go over in main.c is the VBlank interrupt handler: static void VBlankIntr(void) { if (gWirelessCommType != 0) RfuVSync(); else if (gLinkVSyncDisabled == FALSE) LinkVSync(); gMain.vblankCounter1++; if (gTrainerHillVBlankCounter && *gTrainerHillVBlankCounter < 0xFFFFFFFF) (*gTrainerHillVBlankCounter)++; if (gMain.vblankCallback) gMain.vblankCallback(); gMain.vblankCounter2++; CopyBufferedValuesToGpuRegs(); ProcessDma3Requests(); gPcmDmaCounter = gSoundInfo.pcmDmaCounter; m4aSoundMain(); TryReceiveLinkBattleData(); if (!gMain.inBattle || !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_FRONTIER | BATTLE_TYPE_RECORDED))) Random(); UpdateWirelessStatusIndicatorSprite(); INTR_CHECK |= INTR_FLAG_VBLANK; gMain.intrCheck |= INTR_FLAG_VBLANK; } The main steps are: Call the VBLank callback if one is registered; Push pending graphics changes to the video memory; Process this frame's audio; Advance the RNG; Set the flag that AgbMain() waits on each loop. You've likely noticed that special carve-outs for link cable transmissions are scattered around randomly. VBlank also handles displaying an activity indicator for the wireless adapter that I, as someone who was definitely alive at the time, have no recollection about whatsoever but allegedly is a real thing that exists. Finally, they've shoehorned a timer that's only relevant to the Trainer Hill challenge into every single VBlank.","title":"Init and Main"},{"location":"initmain/#init-and-main","text":"Everyone who has programmed in C/C++ or even been tangentially exposed to it knows about main \u2013 the special name reserved for the function that will first run when the program begins. This is, of course, perched on a throne of lies; it's not the first to run, it's just the first to run after some boring housekeeping stuff that is essentially identical in every program on a given platform and generally inserted automatically by the compiler. Of course, we are insisting on running bare-metal on a tiny toy for children and so we get to manually include our own pre- main initialization steps. As mentioned previously, the ROM header contains the first instruction of the game at 0x08000000 , which we can see is b Init , where b (ranch) is equivalent to goto . The Init function is located in crt0.s which is simply a conventionalized name for the code that initializes the C runtime. It is written in assembly because it needs to interface directly with the specific hardware at hand in a way that cannot be expressed at the C abstraction level. If you want to look up more about any of the opcodes, keep in mind that the GBA is a 32-bit ARM architecture with THUMB support, not an x86 one. Note 32-bit ARM processors can run in two distinct modes, dubbed ARM and THUMB, and switch between them on a function-by-function basis. ARM opcodes are four bytes each and THUMB opcodes are two bytes each, and hence can encode less information per operation but in many cases will make the function much smaller overall for the purposes of reducing ROM size. The switching modes is done with a clever trick: since opcodes are always aligned in memory (starting on a multiple of 4 or 2 depending on their size), there's no such thing as an instruction that starts at an odd address. Hence, the smallest bit of an address can be used as a flag to indicate THUMB mode. If the CPU attempts to branch to an odd-numbered address, it switches to THUMB mode and subtracts one from the address before branching. When it branches to an even one, it switches to ARM mode.","title":"Init and Main"},{"location":"initmain/#crt0s","text":"Init:: mov r0, #PSR_IRQ_MODE msr cpsr_cf, r0 ldr sp, sp_irq mov r0, #PSR_SYS_MODE msr cpsr_cf, r0 ldr sp, sp_sys ldr r1, =INTR_VECTOR adr r0, IntrMain str r0, [r1] .if MODERN mov r0, #255 @ RESET_ALL svc #1 << 16 .endif @ MODERN ldr r1, =AgbMain + 1 mov lr, pc bx r1 b Init Do not panic if this is completely incomprehensible. The vast majority of the game is written in C. This code relies heavily on writing magic numbers to magic registers that can only be understood with manufacturer documentation. It first initializes the IRQ (interrupt request) stack at the very end of fast RAM, reserving a small amount of space for the hardware to store information about events the game will want to process. It then initializes the system stack for the arguments of functions, also in fast RAM (IWRAM). Within a specific slot of the IRQ stack we just set up, specifically INTR_VECTOR == 0x3007FFC , we store the address of the function IntrMain so it can be called to process interrupts. The .if MODERN brackets our first optional deviation from the original game, although it's just moving the operation from immediately after AgbMain begins to immediately before it to keep compilers happy. The svc or supervisor call instruction is an alternate name for the swi or software interrupt instruction which will call into the utility functions stored in the BIOS. Due to Reasons, the index number of the requested interrupt needs to be different depending on whether the CPU is currently in ARM or THUMB mode. Since we are in ARM mode, we need to take the index we want and shift it by 16. BIOS function #1 is RegisterRamReset (reminder: documentation ) and we are calling it with an argument of RESET_ALL , meaning all registers and RAM (except for a small carve-out for the IRQ area, which it knows to leave alone) will be set to a clean state of 0. While a game may seem to work fine without doing this, it is a very good idea to always reset memory to a known state. On real hardware, the RAM and registers will power on with random values due to electrical noise. This can lead to random bugs that cannot be reproduced at will. (Emulators usually clean the pretend RAM and registers before emulation begins, but they are not required to do so.) Note A real-world example of a bug introduced by not clearing RAM can see seen in Super Mario All-Stars . If a certain byte in RAM happened to randomly settle to 0x80 when the Super Nintendo was powered on, the game would mistakenly believe it was a developer system and enable debug mode. Since this randomization is determined by the physical environment, some Super Nintendos were more prone to initializing in that exact way than others, and hence some people seemingly had a \"debug copy\" of the game. Finally, the address of AGBMain is loaded (consult the note above on THUMB for why we add 1) and called. If AGBMain ever returns (it shouldn't!) then the last instruction of Init will loop back to the first. Otherwise, since there is no other layer underneath to return to, execution would simply proceed to whatever happened to be next in memory \u2013 which in this case is some constants referenced by Init which aren't meant to be executed as instructions. IntrMain , which was installed by Init as the interrupt handler, mostly consists of an if-cascade that checks for each interrupt flag one at a time, incrementing an index in r12 as it goes. The bit that actually makes things happen is small: ldr r1, =gIntrTable add r1, r1, r12 ldr r0, [r1] stmfd sp!, {lr} adr lr, IntrMain_RetAddr bx r0 This simply indexes into gIntrTable , which will be set up later, and calls whatever function it finds there. Note that interrupts are not yet enabled as of the moment we are stepping into AgbMain and hence there's no danger of IntrMain being called before the table is filled out. That's it \u2013 that's every bit of secret pre- main initialization starting from the cartridge's first instruction. We may now progress to the master game loop.","title":"crt0.s"},{"location":"initmain/#mainc","text":"Just as a curiosity, we can see the exact moment that the final build of the English edition of Emerald was compiled: const char BuildDateTime[] = \"2005 02 21 11:10\"; Note that's a few months before the game went on sale; physical cartridges have a lot of lead time. Clearly, this time stamp was patched in by the build tools rather than manually typed into the original source code. (Specifically, a header file containing nothing but the current timestamp was generated at each compile time by the Makefile.) It's preserved here exactly as it was so that the ROM can be recompiled back to the same state. Another curiosity is that the leaked source dump has a timestamp of \"2005 06 14 15:20\" , so it appears to be a backup made while preparing the European release that launched in October. The final Spanish ROM's timestamp is two weeks later: \"2005 07 01 18:30\" . (Almost all such leaks come from third party localizers who needed the ability to edit the source code directly. The disks they were mailed kick around in someone's garage until someone else who never signed a contract with the publisher finds them.) In IntrMain we saw an interrupt table which had not yet been initialized. Its default state is encoded here, with many of the entries set to a dummy placeholder as the game does not actually care about them: const IntrFunc gIntrTableTemplate[] = { VCountIntr, // V-count interrupt SerialIntr, // Serial interrupt Timer3Intr, // Timer 3 interrupt HBlankIntr, // H-blank interrupt VBlankIntr, // V-blank interrupt IntrDummy, // Timer 0 interrupt IntrDummy, // Timer 1 interrupt IntrDummy, // Timer 2 interrupt IntrDummy, // DMA 0 interrupt IntrDummy, // DMA 1 interrupt IntrDummy, // DMA 2 interrupt IntrDummy, // DMA 3 interrupt IntrDummy, // Key interrupt IntrDummy, // Game Pak interrupt }; Note HBlank and VBlank are terms dating from the CRT television era. The pixels of the screen are updated left-to-right and top-to-bottom each frame. The horizontal blank interrupt activates each time the end of a row of pixels is reached (hence 160x per frame) and the vertical blank interrupt activates each time the end of rendering is reached and the screen will return to the first pixel in the upper left (hence definitionally once per frame, very slightly faster than 60x per second). This lets the game know when it's time to update the visuals that will be rendered to the screen. It is the responsibility of the programmer to keep the handlers for these interrupts as short as possible; it would be very bad if VBlank activated while only halfway through processing the previous VBlank! Next are a messy set of miscellaneous globals for tracking game state: static u16 sUnusedVar; // Never read u16 gKeyRepeatStartDelay; bool8 gLinkTransferringData; struct Main gMain; u16 gKeyRepeatContinueDelay; bool8 gSoftResetDisabled; IntrFunc gIntrTable[INTR_COUNT]; u8 gLinkVSyncDisabled; u32 IntrMain_Buffer[0x200]; s8 gPcmDmaCounter; static EWRAM_DATA u16 sTrainerId = 0; The one marked unused is named mssize in the original code and is set to the sizeof() of a structure used for multiplayer on the serial cable. It's presumably vestigial from early scaffolding. The gMain structure is defined in main.h and bundles together several things that are constantly relevant in every phase of the game: struct Main { /*0x000*/ MainCallback callback1; /*0x004*/ MainCallback callback2; /*0x008*/ MainCallback savedCallback; /*0x00C*/ IntrCallback vblankCallback; /*0x010*/ IntrCallback hblankCallback; /*0x014*/ IntrCallback vcountCallback; /*0x018*/ IntrCallback serialCallback; /*0x01C*/ vu16 intrCheck; /*0x020*/ u32 vblankCounter1; /*0x024*/ u32 vblankCounter2; /*0x028*/ u16 heldKeysRaw; // held keys without L=A remapping /*0x02A*/ u16 newKeysRaw; // newly pressed keys without L=A remapping /*0x02C*/ u16 heldKeys; // held keys with L=A remapping /*0x02E*/ u16 newKeys; // newly pressed keys with L=A remapping /*0x030*/ u16 newAndRepeatedKeys; // newly pressed keys plus key repeat /*0x032*/ u16 keyRepeatCounter; // counts down to 0, triggering key repeat /*0x034*/ bool16 watchedKeysPressed; // whether one of the watched keys was pressed /*0x036*/ u16 watchedKeysMask; // bit mask for watched keys /*0x038*/ struct OamData oamBuffer[128]; /*0x438*/ u8 state; /*0x439*/ u8 oamLoadDisabled:1; /*0x439*/ u8 inBattle:1; /*0x439*/ u8 anyLinkBattlerHasFrontierPass:1; }; Zoom. Enhance. u8 state; This is a load-bearing byte. gMain.state is the master state machine tracker value. It's updated in over 500 locations across several dozen source files. Each distinct type of screen (title screen, evolution screen, etc) uses it to keep track of where it is in its sequence of possible events. The meaning of each possible value is specific to each screen. In a hypothetically perfect engine each game mode should track its state independently, but memory is tight and it's not possible for more than one to be running concurrently. The actual main function is pretty concise, and on a first reading you will almost certainly miss where the actual game happens: void AgbMain() { // Modern compilers are liberal with the stack on entry to this function, // so RegisterRamReset may crash if it resets IWRAM. #if !MODERN RegisterRamReset(RESET_ALL); #endif //MODERN *(vu16 *)BG_PLTT = RGB_WHITE; // Set the backdrop to white on startup InitGpuRegManager(); REG_WAITCNT = WAITCNT_PREFETCH_ENABLE | WAITCNT_WS0_S_1 | WAITCNT_WS0_N_3; InitKeys(); InitIntrHandlers(); m4aSoundInit(); EnableVCountIntrAtLine150(); InitRFU(); RtcInit(); CheckForFlashMemory(); InitMainCallbacks(); InitMapMusic(); #ifdef BUGFIX SeedRngWithRtc(); // see comment at SeedRngWithRtc definition below #endif ClearDma3Requests(); ResetBgs(); SetDefaultFontsPointer(); InitHeap(gHeap, HEAP_SIZE); gSoftResetDisabled = FALSE; if (gFlashMemoryPresent != TRUE) SetMainCallback2(NULL); gLinkTransferringData = FALSE; sUnusedVar = 0xFC0; #ifndef NDEBUG #if (LOG_HANDLER == LOG_HANDLER_MGBA_PRINT) (void) MgbaOpen(); #elif (LOG_HANDLER == LOG_HANDLER_AGB_PRINT) AGBPrintfInit(); #endif #endif for (;;) { ReadKeys(); if (gSoftResetDisabled == FALSE && JOY_HELD_RAW(A_BUTTON) && JOY_HELD_RAW(B_START_SELECT) == B_START_SELECT) { rfu_REQ_stopMode(); rfu_waitREQComplete(); DoSoftReset(); } if (Overworld_SendKeysToLinkIsRunning() == TRUE) { gLinkTransferringData = TRUE; UpdateLinkAndCallCallbacks(); gLinkTransferringData = FALSE; } else { gLinkTransferringData = FALSE; UpdateLinkAndCallCallbacks(); if (Overworld_RecvKeysFromLinkIsRunning() == TRUE) { gMain.newKeys = 0; ClearSpriteCopyRequests(); gLinkTransferringData = TRUE; UpdateLinkAndCallCallbacks(); gLinkTransferringData = FALSE; } } PlayTimeCounter_Update(); MapMusicMain(); WaitForVBlank(); } } Did you spot it? The game happens inside UpdateLinkAndCallCallbacks() . A callback is when a function's address is stored in a variable by one piece of code so that another piece of code will later call it without necessarily knowing or caring exactly what it will do. Various pieces of game logic will stash functions in the callback variables (we saw them in the gMain struct) for AgbMain to call on its next loop and keep the game moving. The very first callbacks are initialized in the helper function InitMainCallbacks() \u2013 technically only one is set, CB2_InitCopyrightScreenAfterBootup() . We will check it out later. If you browse the various helper functions called in the initialization stage of the main function, you will see something that is traditionally a no-no in application programming \u2013 writing directly to a specific hard-coded address: void StartTimer1(void) { REG_TM1CNT_H = 0x80; } (Where REG_TM1CNT_H == 0x04000106 after chasing it down through multiple layers of defines.) When working directly with the real, unprotected memory space of a device, it is typical for specific addresses to be physically wired to hardware components for the purpose of interacting with them. These addresses are unique to every kind of device and must be looked up in documentation . This address is connected to \"Timer 1 Control\", and by setting it to 0x80 (better understood as 0b10000000 since it is a set of bit flags) the timer is enabled and starts ticking. There's actually a very serious bug in AgbMain() , one which has a huge impact on advanced gameplay such as speedrunning and shiny hunting: they forgot to seed the RNG. They straight-up forgot! In Ruby/Sapphire, there is a call to SeedRngWithRtc() following InitMapMusic() : static void SeedRngWithRtc(void) { u32 seed = RtcGetMinuteCount(); seed = (seed >> 16) ^ (seed & 0xFFFF); SeedRng(seed); } This means there are thousands of different RNG streams from power-on depending on what value was pulled from the real-time clock, which keeps running when the game is off. This code was removed for Fire Red/Leaf Green as these were ports of older games with no RTC. When they sat down to hack together Emerald, it seems the team used the version of AgbMain they had made for FRLG rather than RS. They forgot to restore the RNG initialization, and so now every legitimate copy of Emerald is stuck booting with an RNG value of 0x0000 . The PRET decompiliation will include SeedRngWithRtc() at the correct place if BUGFIX compile mode is enabled, which allows you to experience an alternate reality where randomness is slightly more actually random. This is a classic Game Freak bug: understandable how it happened, but a solid gameplay testing process should have caught it. Note RNG (random number generation) can only be \"truly\" random if it is reading from a physical random process such as radioactive decay. Algorithms that can run quickly on something like a Game Boy Advance are a very rough approximation, and require a kick-off random number, the \"seed\", so that they do not simply produce the same sequence each time the game is run. While a linearly increasing clock is not very random at all, the exact value at whatever time you happen to turn on the game might as well be for basic seeding purposes. The seed being stuck at zero after every reboot in Emerald means that the exact same series of player inputs will always result in the same series of events such as wild encounters, critical hits, capture successes, and what stats are assigned to newly captured mons. Fortunately, normal players are divergent enough in their inputs that the broken RNG is not too wildly obvious. (Shiny hunters are Not Normal.) There is another bug just in the functions called directly from AgbMain : if the option is set to treat the \"L\" button as equivalent to the \"A\" button, ReadKeys() won't correctly do key repeat for the \"L\" as an \"A\". Another bug that should have been found in testing, and this one is an original sin of Ruby/Sapphire. Ignoring complications introduced by whether or not the link cable is active, the structure of the infinite game loop is straightforward: Check which buttons are pressed on the controller; Check whether it's time to do a soft reset; Call the currently registered callbacks, which contain the game logic; Update how long the game has been running; Do some bookkeeping with the music; Wait for the end of the VBlank interrupt which signals the end of the frame. The last step keeps everything synchronized by ensuring everything happens once per 60th of a second. If too much work is done in a callback to meet the frame deadline, it can cause audio-visual issues. The last thing we'll go over in main.c is the VBlank interrupt handler: static void VBlankIntr(void) { if (gWirelessCommType != 0) RfuVSync(); else if (gLinkVSyncDisabled == FALSE) LinkVSync(); gMain.vblankCounter1++; if (gTrainerHillVBlankCounter && *gTrainerHillVBlankCounter < 0xFFFFFFFF) (*gTrainerHillVBlankCounter)++; if (gMain.vblankCallback) gMain.vblankCallback(); gMain.vblankCounter2++; CopyBufferedValuesToGpuRegs(); ProcessDma3Requests(); gPcmDmaCounter = gSoundInfo.pcmDmaCounter; m4aSoundMain(); TryReceiveLinkBattleData(); if (!gMain.inBattle || !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_FRONTIER | BATTLE_TYPE_RECORDED))) Random(); UpdateWirelessStatusIndicatorSprite(); INTR_CHECK |= INTR_FLAG_VBLANK; gMain.intrCheck |= INTR_FLAG_VBLANK; } The main steps are: Call the VBLank callback if one is registered; Push pending graphics changes to the video memory; Process this frame's audio; Advance the RNG; Set the flag that AgbMain() waits on each loop. You've likely noticed that special carve-outs for link cable transmissions are scattered around randomly. VBlank also handles displaying an activity indicator for the wireless adapter that I, as someone who was definitely alive at the time, have no recollection about whatsoever but allegedly is a real thing that exists. Finally, they've shoehorned a timer that's only relevant to the Trainer Hill challenge into every single VBlank.","title":"main.c"},{"location":"layout/","text":"Overall Structure and Layout When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means variables that always have a value and .bss means variables that do not always have a value. .rodata is read-only data which is, at least, actually what it sounds like. Memory Map Summary Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer. ROM header The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's first executable instruction (which just jumps to the entry point), its name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher). It also contains the CRC checksum that the BIOS uses during its validity check to detect a corrupt cartridge. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about: rom_header_gf.c static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It was intended as padding to reserve a full 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length (256 - 344) actually has a length of one rather than throwing an error, which would have brought it to their attention as no longer needed. Source Directory Layout Most of the C source files that make up the bulk of the engine are in src/ but there are a few outside of it ( gflib/ ) and assembly source files ( .s ) are scattered across several folders. asm/ contains macro definitions for the scripting engine; data/ contains an enormous amount of assorted high-level game data such as event scripts, in-game text, tilesets and maps; graphics/ contains visuals other than tilesets; include/ is C headers; sound/ includes songs and sound effects; tools/ contains utilities used in the build process that are not part of the game itself. Here you will find the scripts that convert the easily-editable forms of images and music stored in the repo to the formats expected by the game and gbafix which patches the final CRC into the header. If you add new data resources to the game, you will likely need to wade into src/data/ and find the right header to patch to actually incorporate it into the ROM by name. Continue on to Init and Main","title":"Overall Structure and Layout"},{"location":"layout/#overall-structure-and-layout","text":"When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means variables that always have a value and .bss means variables that do not always have a value. .rodata is read-only data which is, at least, actually what it sounds like.","title":"Overall Structure and Layout"},{"location":"layout/#memory-map-summary","text":"Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer.","title":"Memory Map Summary"},{"location":"layout/#rom-header","text":"The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's first executable instruction (which just jumps to the entry point), its name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher). It also contains the CRC checksum that the BIOS uses during its validity check to detect a corrupt cartridge. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about:","title":"ROM header"},{"location":"layout/#rom_header_gfc","text":"static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It was intended as padding to reserve a full 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length (256 - 344) actually has a length of one rather than throwing an error, which would have brought it to their attention as no longer needed.","title":"rom_header_gf.c"},{"location":"layout/#source-directory-layout","text":"Most of the C source files that make up the bulk of the engine are in src/ but there are a few outside of it ( gflib/ ) and assembly source files ( .s ) are scattered across several folders. asm/ contains macro definitions for the scripting engine; data/ contains an enormous amount of assorted high-level game data such as event scripts, in-game text, tilesets and maps; graphics/ contains visuals other than tilesets; include/ is C headers; sound/ includes songs and sound effects; tools/ contains utilities used in the build process that are not part of the game itself. Here you will find the scripts that convert the easily-editable forms of images and music stored in the repo to the formats expected by the game and gbafix which patches the final CRC into the header. If you add new data resources to the game, you will likely need to wade into src/data/ and find the right header to patch to actually incorporate it into the ROM by name. Continue on to Init and Main","title":"Source Directory Layout"}]}