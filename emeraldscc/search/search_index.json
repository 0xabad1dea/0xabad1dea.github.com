{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emerald Source Code Commentary by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original commercial source code. This is a courtesy notice to anyone obligated to maintain a clean-room status. Introduction Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit. Decompiliation It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's... unauthorized, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: some of the functionality is unlocalized, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, the way in-game text is represented is a nightmare and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Tools) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Introduction"},{"location":"#emerald-source-code-commentary","text":"by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original commercial source code. This is a courtesy notice to anyone obligated to maintain a clean-room status.","title":"Emerald Source Code Commentary"},{"location":"#introduction","text":"Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit.","title":"Introduction"},{"location":"#decompiliation","text":"It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's... unauthorized, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: some of the functionality is unlocalized, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, the way in-game text is represented is a nightmare and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Tools) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Decompiliation"},{"location":"about/","text":"About The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"about/#about","text":"The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"initmain/","text":"Init and Main Everyone who has programmed in C/C++ or even been tangentially exposed to it knows about main \u2013 the special name reserved for the function that will first run when the program begins. This is, of course, perched on a throne of lies; it's not the first to run, it's just the first to run after some boring housekeeping stuff that is essentially identical in every program on a given platform and generally inserted automatically by the compiler. Of course, we are insisting on running bare-metal on a tiny toy for children and so we get to manually include our own pre- main initialization steps. As mentioned previously, the ROM header contains the first instruction of the game at 0x08000000 , which we can see is b Init , where b (ranch) is equivalent to goto . The Init function is located in crt0.s which is simply a conventionalized name for the code that initializes the C runtime. It is written in assembly because it needs to interface directly with the specific hardware at hand in a way that cannot be expressed at the C abstraction level. If you want to look up more about any of the opcodes, keep in mind that the GBA is a 32-bit ARM architecture with THUMB support, not an x86 one. Note 32-bit ARM processors can run in two distinct modes, dubbed ARM and THUMB, and switch between them on a function-by-function basis. ARM opcodes are four bytes each and THUMB opcodes are two bytes each, and hence can encode less information per operation but in many cases will make the function much smaller overall for the purposes of reducing ROM size. The switching modes is done with a clever trick: since opcodes are always aligned in memory (starting on a multiple of 4 or 2 depending on their size), there's no such thing as an instruction that starts at an odd address. Hence, the smallest bit of an address can be used as a flag to indicate THUMB mode. If the CPU attempts to branch to an odd-numbered address, it switches to THUMB mode and subtracts one from the address before branching. When it branches to an even one, it switches to ARM mode. crt0.s Init:: mov r0, #PSR_IRQ_MODE msr cpsr_cf, r0 ldr sp, sp_irq mov r0, #PSR_SYS_MODE msr cpsr_cf, r0 ldr sp, sp_sys ldr r1, =INTR_VECTOR adr r0, IntrMain str r0, [r1] .if MODERN mov r0, #255 @ RESET_ALL svc #1 << 16 .endif @ MODERN ldr r1, =AgbMain + 1 mov lr, pc bx r1 b Init Do not panic if this is completely incomprehensible. The vast majority of the game is written in C. This code relies heavily on writing magic numbers to magic registers that can only be understood with manufacturer documentation. It first initializes the IRQ (interrupt request) stack at the very end of fast RAM, reserving a small amount of space for the hardware to store information about events the game will want to process. It then initializes the system stack for the arguments of functions, also in fast RAM (IWRAM). Within a specific slot of the IRQ stack we just set up, specifically INTR_VECTOR == 0x3007FFC , we store the address of the function IntrMain so it can be called to process interrupts. The .if MODERN brackets our first optional deviation from the original game, although it's just moving the operation from immediately after AgbMain begins to immediately before it to keep compilers happy. The svc or supervisor call instruction is an alternate name for the swi or software interrupt instruction which will call into the utility functions stored in the BIOS. Due to Reasons, the index number of the requested interrupt needs to be different depending on whether the CPU is currently in ARM or THUMB mode. Since we are in ARM mode, we need to take the index we want and shift it by 16. BIOS function #1 is RegisterRamReset (reminder: documentation ) and we are calling it with an argument of RESET_ALL , meaning all registers and RAM (except for a small carve-out for the IRQ area, which it knows to leave alone) will be set to a clean state of 0. While a game may seem to work fine without doing this, it is a very good idea to always reset memory to a known state. On real hardware, the RAM and registers will power on with random values due to electrical noise. This can lead to random bugs that cannot be reproduced at will. (Emulators usually clean the pretend RAM and registers before emulation begins, but they are not required to do so.) Note A real-world example of a bug introduced by not clearing RAM can see seen in Super Mario All-Stars . If a certain byte in RAM happened to randomly settle to 0x80 when the Super Nintendo was powered on, the game would mistakenly believe it was a developer system and enable debug mode. Since this randomization is determined by the physical environment, some Super Nintendos were more prone to initializing in that exact way than others, and hence some people seemingly had a \"debug copy\" of the game. Finally, the address of AGBMain is loaded (consult the note above on THUMB for why we add 1) and called. If AGBMain ever returns (it shouldn't!) then the last instruction of Init will loop back to the first. Otherwise, since there is no other layer underneath to return to, execution would simply proceed to whatever happened to be next in memory \u2013 which in this case is some constants referenced by Init which aren't meant to be executed as instructions. IntrMain , which was installed by Init as the interrupt handler, mostly consists of an if-cascade that checks for each interrupt flag one at a time, incrementing an index in r12 as it goes. The bit that actually makes things happen is small: ldr r1, =gIntrTable add r1, r1, r12 ldr r0, [r1] stmfd sp!, {lr} adr lr, IntrMain_RetAddr bx r0 This simply indexes into gIntrTable , which will be set up later, and calls whatever function it finds there. Note that interrupts are not yet enabled as of the moment we are stepping into AgbMain and hence there's no danger of IntrMain being called before the table is filled out. That's it \u2013 that's every bit of secret pre- main initialization starting from the cartridge's first instruction. We may now progress to the master game loop. main.c Just as a curiosity, we can see the exact moment that the final build of the English edition of Emerald was compiled: const char BuildDateTime[] = \"2005 02 21 11:10\"; Note that's a few months before the game went on sale; physical cartridges have a lot of lead time. Clearly, this time stamp was patched in by the build tools rather than manually typed into the original source code. (Specifically, a header file containing nothing but the current timestamp was generated at each compile time by the Makefile.) It's preserved here exactly as it was so that the ROM can be recompiled back to the same state. Another curiosity is that the leaked source dump has a timestamp of \"2005 06 14 15:20\" , so it appears to be a backup made while preparing the European release that launched in October. The final Spanish ROM's timestamp is two weeks later: \"2005 07 01 18:30\" . (Almost all such leaks come from third party localizers who needed the ability to edit the source code directly. The disks they were mailed kick around in someone's garage until someone else who never signed a contract with the publisher finds them.) In IntrMain we saw an interrupt table which had not yet been initialized. Its default state is encoded here, with many of the entries set to a dummy placeholder as they'll be swapped out dynamically: const IntrFunc gIntrTableTemplate[] = { VCountIntr, // V-count interrupt SerialIntr, // Serial interrupt Timer3Intr, // Timer 3 interrupt HBlankIntr, // H-blank interrupt VBlankIntr, // V-blank interrupt IntrDummy, // Timer 0 interrupt IntrDummy, // Timer 1 interrupt IntrDummy, // Timer 2 interrupt IntrDummy, // DMA 0 interrupt IntrDummy, // DMA 1 interrupt IntrDummy, // DMA 2 interrupt IntrDummy, // DMA 3 interrupt IntrDummy, // Key interrupt IntrDummy, // Game Pak interrupt }; Next are a messy set of miscellaneous globals for tracking game state: static u16 sUnusedVar; // Never read u16 gKeyRepeatStartDelay; bool8 gLinkTransferringData; struct Main gMain; u16 gKeyRepeatContinueDelay; bool8 gSoftResetDisabled; IntrFunc gIntrTable[INTR_COUNT]; u8 gLinkVSyncDisabled; u32 IntrMain_Buffer[0x200]; s8 gPcmDmaCounter; static EWRAM_DATA u16 sTrainerId = 0; The one marked unused is named mssize in the original code and is set to the sizeof() of a structure used for multiplayer on the serial cable. It's presumably vestigial from early scaffolding.","title":"Init and Main"},{"location":"initmain/#init-and-main","text":"Everyone who has programmed in C/C++ or even been tangentially exposed to it knows about main \u2013 the special name reserved for the function that will first run when the program begins. This is, of course, perched on a throne of lies; it's not the first to run, it's just the first to run after some boring housekeeping stuff that is essentially identical in every program on a given platform and generally inserted automatically by the compiler. Of course, we are insisting on running bare-metal on a tiny toy for children and so we get to manually include our own pre- main initialization steps. As mentioned previously, the ROM header contains the first instruction of the game at 0x08000000 , which we can see is b Init , where b (ranch) is equivalent to goto . The Init function is located in crt0.s which is simply a conventionalized name for the code that initializes the C runtime. It is written in assembly because it needs to interface directly with the specific hardware at hand in a way that cannot be expressed at the C abstraction level. If you want to look up more about any of the opcodes, keep in mind that the GBA is a 32-bit ARM architecture with THUMB support, not an x86 one. Note 32-bit ARM processors can run in two distinct modes, dubbed ARM and THUMB, and switch between them on a function-by-function basis. ARM opcodes are four bytes each and THUMB opcodes are two bytes each, and hence can encode less information per operation but in many cases will make the function much smaller overall for the purposes of reducing ROM size. The switching modes is done with a clever trick: since opcodes are always aligned in memory (starting on a multiple of 4 or 2 depending on their size), there's no such thing as an instruction that starts at an odd address. Hence, the smallest bit of an address can be used as a flag to indicate THUMB mode. If the CPU attempts to branch to an odd-numbered address, it switches to THUMB mode and subtracts one from the address before branching. When it branches to an even one, it switches to ARM mode.","title":"Init and Main"},{"location":"initmain/#crt0s","text":"Init:: mov r0, #PSR_IRQ_MODE msr cpsr_cf, r0 ldr sp, sp_irq mov r0, #PSR_SYS_MODE msr cpsr_cf, r0 ldr sp, sp_sys ldr r1, =INTR_VECTOR adr r0, IntrMain str r0, [r1] .if MODERN mov r0, #255 @ RESET_ALL svc #1 << 16 .endif @ MODERN ldr r1, =AgbMain + 1 mov lr, pc bx r1 b Init Do not panic if this is completely incomprehensible. The vast majority of the game is written in C. This code relies heavily on writing magic numbers to magic registers that can only be understood with manufacturer documentation. It first initializes the IRQ (interrupt request) stack at the very end of fast RAM, reserving a small amount of space for the hardware to store information about events the game will want to process. It then initializes the system stack for the arguments of functions, also in fast RAM (IWRAM). Within a specific slot of the IRQ stack we just set up, specifically INTR_VECTOR == 0x3007FFC , we store the address of the function IntrMain so it can be called to process interrupts. The .if MODERN brackets our first optional deviation from the original game, although it's just moving the operation from immediately after AgbMain begins to immediately before it to keep compilers happy. The svc or supervisor call instruction is an alternate name for the swi or software interrupt instruction which will call into the utility functions stored in the BIOS. Due to Reasons, the index number of the requested interrupt needs to be different depending on whether the CPU is currently in ARM or THUMB mode. Since we are in ARM mode, we need to take the index we want and shift it by 16. BIOS function #1 is RegisterRamReset (reminder: documentation ) and we are calling it with an argument of RESET_ALL , meaning all registers and RAM (except for a small carve-out for the IRQ area, which it knows to leave alone) will be set to a clean state of 0. While a game may seem to work fine without doing this, it is a very good idea to always reset memory to a known state. On real hardware, the RAM and registers will power on with random values due to electrical noise. This can lead to random bugs that cannot be reproduced at will. (Emulators usually clean the pretend RAM and registers before emulation begins, but they are not required to do so.) Note A real-world example of a bug introduced by not clearing RAM can see seen in Super Mario All-Stars . If a certain byte in RAM happened to randomly settle to 0x80 when the Super Nintendo was powered on, the game would mistakenly believe it was a developer system and enable debug mode. Since this randomization is determined by the physical environment, some Super Nintendos were more prone to initializing in that exact way than others, and hence some people seemingly had a \"debug copy\" of the game. Finally, the address of AGBMain is loaded (consult the note above on THUMB for why we add 1) and called. If AGBMain ever returns (it shouldn't!) then the last instruction of Init will loop back to the first. Otherwise, since there is no other layer underneath to return to, execution would simply proceed to whatever happened to be next in memory \u2013 which in this case is some constants referenced by Init which aren't meant to be executed as instructions. IntrMain , which was installed by Init as the interrupt handler, mostly consists of an if-cascade that checks for each interrupt flag one at a time, incrementing an index in r12 as it goes. The bit that actually makes things happen is small: ldr r1, =gIntrTable add r1, r1, r12 ldr r0, [r1] stmfd sp!, {lr} adr lr, IntrMain_RetAddr bx r0 This simply indexes into gIntrTable , which will be set up later, and calls whatever function it finds there. Note that interrupts are not yet enabled as of the moment we are stepping into AgbMain and hence there's no danger of IntrMain being called before the table is filled out. That's it \u2013 that's every bit of secret pre- main initialization starting from the cartridge's first instruction. We may now progress to the master game loop.","title":"crt0.s"},{"location":"initmain/#mainc","text":"Just as a curiosity, we can see the exact moment that the final build of the English edition of Emerald was compiled: const char BuildDateTime[] = \"2005 02 21 11:10\"; Note that's a few months before the game went on sale; physical cartridges have a lot of lead time. Clearly, this time stamp was patched in by the build tools rather than manually typed into the original source code. (Specifically, a header file containing nothing but the current timestamp was generated at each compile time by the Makefile.) It's preserved here exactly as it was so that the ROM can be recompiled back to the same state. Another curiosity is that the leaked source dump has a timestamp of \"2005 06 14 15:20\" , so it appears to be a backup made while preparing the European release that launched in October. The final Spanish ROM's timestamp is two weeks later: \"2005 07 01 18:30\" . (Almost all such leaks come from third party localizers who needed the ability to edit the source code directly. The disks they were mailed kick around in someone's garage until someone else who never signed a contract with the publisher finds them.) In IntrMain we saw an interrupt table which had not yet been initialized. Its default state is encoded here, with many of the entries set to a dummy placeholder as they'll be swapped out dynamically: const IntrFunc gIntrTableTemplate[] = { VCountIntr, // V-count interrupt SerialIntr, // Serial interrupt Timer3Intr, // Timer 3 interrupt HBlankIntr, // H-blank interrupt VBlankIntr, // V-blank interrupt IntrDummy, // Timer 0 interrupt IntrDummy, // Timer 1 interrupt IntrDummy, // Timer 2 interrupt IntrDummy, // DMA 0 interrupt IntrDummy, // DMA 1 interrupt IntrDummy, // DMA 2 interrupt IntrDummy, // DMA 3 interrupt IntrDummy, // Key interrupt IntrDummy, // Game Pak interrupt }; Next are a messy set of miscellaneous globals for tracking game state: static u16 sUnusedVar; // Never read u16 gKeyRepeatStartDelay; bool8 gLinkTransferringData; struct Main gMain; u16 gKeyRepeatContinueDelay; bool8 gSoftResetDisabled; IntrFunc gIntrTable[INTR_COUNT]; u8 gLinkVSyncDisabled; u32 IntrMain_Buffer[0x200]; s8 gPcmDmaCounter; static EWRAM_DATA u16 sTrainerId = 0; The one marked unused is named mssize in the original code and is set to the sizeof() of a structure used for multiplayer on the serial cable. It's presumably vestigial from early scaffolding.","title":"main.c"},{"location":"layout/","text":"Overall Structure and Layout When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means variables that always have a value and .bss means variables that do not always have a value. .rodata is read-only data which is, at least, actually what it sounds like. Memory Map Summary Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer. ROM header The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's first executable instruction (which just jumps to the entry point), its name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher). It also contains the CRC checksum that the BIOS uses during its validity check to detect a corrupt cartridge. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about: rom_header_gf.c static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It was intended as padding to reserve a full 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length (256 - 344) actually has a length of one rather than throwing an error, which would have brought it to their attention as no longer needed. Continue on to Init and Main","title":"Overall Structure and Layout"},{"location":"layout/#overall-structure-and-layout","text":"When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means variables that always have a value and .bss means variables that do not always have a value. .rodata is read-only data which is, at least, actually what it sounds like.","title":"Overall Structure and Layout"},{"location":"layout/#memory-map-summary","text":"Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer.","title":"Memory Map Summary"},{"location":"layout/#rom-header","text":"The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's first executable instruction (which just jumps to the entry point), its name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher). It also contains the CRC checksum that the BIOS uses during its validity check to detect a corrupt cartridge. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about:","title":"ROM header"},{"location":"layout/#rom_header_gfc","text":"static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It was intended as padding to reserve a full 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length (256 - 344) actually has a length of one rather than throwing an error, which would have brought it to their attention as no longer needed. Continue on to Init and Main","title":"rom_header_gf.c"}]}