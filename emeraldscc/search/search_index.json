{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Emerald Source Code Commentary by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original copyrighted source code. This is a courtesy notice to anyone obligated to maintain a clean-room status. Introduction Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit. Decompiliation It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's stolen, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: the leaked version is for the Japanese edition of the game without the English translation, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: //---------------------------------------------------------- // \ufffd{\ufffd[\ufffd\ufffd\ufffd\u0331\ufffd\ufffd\ufffdNo\ufffd\ufffd\ufffd\u07b0\u0642\ufffd\u00f0\ufffd\ufffd\ufffdNo\ufffd\u0255\u03ca\ufffd\ufffd\ufffd\ufffd\ufffd //---------------------------------------------------------- case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Team) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Introduction"},{"location":"#emerald-source-code-commentary","text":"by 0xabad1dea, April 2023 The Emerald Source Code Commentary is a book in the spirit of \"A Commentary on the Sixth Edition Unix Operating System\" that examines and explains the source code of one of the most popular video games ever made, based on the decompilation work of PRET . Note It is strongly recommended to have the PRET Emerald repository opened in a tab or downloaded locally to a source code editor while reading. Warning This book will occasionally cite small amounts of the original copyrighted source code. This is a courtesy notice to anyone obligated to maintain a clean-room status.","title":"Emerald Source Code Commentary"},{"location":"#introduction","text":"Video games are a crucial component of modern art and culture. They deserve to be preserved, they deserve to be accessible, and they deserve to be studied. In the 1977 Commentary that introduced so many students to operating systems, J. Lions laid out the case for studying Unix in particular: it runs on a system which is already available to us; it is compact and accessible; it provides an extensive set of very usable facilities; it is intrinsically interesting, and in fact breaks new ground in a number of areas. Pokemon Emerald is a similarly ideal case study for the structure and implementation of video games: the GBA platform can be emulated on absolutely anything; the game is modest in scope and written in C rather than assembly; it embodies every system expected of a 2D tile-based RPG; Pokemon is intrinsically interesting. Released in 2004, Emerald rests at the balance point between small games written entirely in assembly and the modern AAA behemoth. At the ancient end, one spends too much time keeping mental track of registers and status flags to perceive the game; at the other extreme, the code in its totality (to include all the underlying drivers and libraries) is so large that not one single person actually does understand all of it. There is nothing running underneath a GameBoy Advance game. The hardware only runs a boot routine to display the logo and check that the cartridge appears to be valid before jumping to its entry point, at which point the game has absolute control. The BIOS burned into the hardware also contains some utility functions that it was expected almost every game would need; they are well-documented . Absolutely everything else needed to run the game is inside the game itself. It is recommended to check out a general overview of GBA hardware capabilities. The GBATEK document contains the nittiest of grit.","title":"Introduction"},{"location":"#decompiliation","text":"It may be surprising to see a commentary on the source code of a closed-source commercial game, especially from such a notoriously jealous and vengeful company. It so happens that the real, full original source code of Emerald is available on the internet. It's stolen, obviously. Aside from that, there are a few reasons to hesitate from referencing it heavily: the leaked version is for the Japanese edition of the game without the English translation, the comments are in Japanese and in a pre-Unicode encoding that will not render correctly in modern editors, and the variables (which in C must always be in ascii) are written in improvised wasei-eigo indecipherable to anyone but the original programmers: //---------------------------------------------------------- // \ufffd{\ufffd[\ufffd\ufffd\ufffd\u0331\ufffd\ufffd\ufffdNo\ufffd\ufffd\ufffd\u07b0\u0642\ufffd\u00f0\ufffd\ufffd\ufffdNo\ufffd\u0255\u03ca\ufffd\ufffd\ufffd\ufffd\ufffd //---------------------------------------------------------- case ITEM_GOOZYASUBOORU: tblno = EF_GOUJYASU_BALL; break; (Note the two wildly different spellings of the same item name.) Therefore, this commentary is built on the stellar work of PRET (Pokemon Reverse Engineering Team) to produce a new body of decompiled source code that compiles exactly to the official English release of the Emerald ROM down to the last byte. You can browse the code base , download your own copy, compile it, and freely make changes. The comments and variable names follow English coding conventions. Reverse engineering the game to this level of perfection was an enormous amount of work and it was not done by the author of the Commentary. Please check the contributors page for more information. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. Since the decomp is based on the commercial release, all the debug tooling present in beta builds of the game is absent. Check The Cutting Room Floor for information on the Japanese-only debug tooling present in the leaked original source code. You can also consult the debug functionality present in Ruby/Sapphire . Like all Pokemon games, Emerald is riddled with bugs. In addition to reproducing the original ROM, the PRET code base also supports alternate compilation settings to fix logic bugs and avoid undefined behavior that angers a modern, more standards-compliant compiler. You will see these optional code snippets inside #IFDEF blocks. Continue on to Overall Structure and Layout .","title":"Decompiliation"},{"location":"about/","text":"About The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"about/#about","text":"The Emerald Source Code Commentary was written by 0xabad1dea (pronounced \"a bad idea\", she/her pronouns) based on the stellar decompiliation work of PRET . All credit for the enormous reverse engineering process belongs to them and I am only responsible for the explanatory prose. Due to ongoing improvements in matters such as variable names and file structure, the current state of the PRET repository may not be identical to the code as quoted in the Commentary. However, since it is a round-trip decompiliation (that is, it recompiles to its exact original state), the code as a whole will always be functionally identical. You may freely download and share this document. You may convert file formats or translate to another language as long as the contents are semantically preserved. Warning Do Not Commit Copyright Crimes Against Any Major Japanese Corporations That Could Get My Repo Pulled","title":"About"},{"location":"layout/","text":"Overall Structure and Layout When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means global or static variables (those which always have a persistent value) and .bss means transient variables that pop in and out of existence when their functions run. .rodata is read-only data which is, at least, actually what it sounds like. Memory Map Summary Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer. ROM header The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher.) It also contains the address of the entry point which the BIOS should jump to after it's satisfied the cartridge is valid, and the CRC checksum that the BIOS will compare against after checksumming the cartridge itself to make that validity check. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about: rom_header_gf.c static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It seems to be intended as padding to fill out 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length actually has a length of one rather than throwing an error which would have brought it to their attention as no longer needed.","title":"Overall Structure and Layout"},{"location":"layout/#overall-structure-and-layout","text":"When you write a typical C application for a modern operating system, you do not need to pay very much heed to the exact layout of system memory nor spell out a great many details to the linker about how your program needs to be loaded. Decades of abstraction layers insulate you and provide a highly standardized, sanitized environment for your program's running process. The GameBoy Advance is a bare-metal environment. There is no operating system \u2013 or the game is its own operating system, whichever viewpoint one prefers. While the idealized memory abstraction presented to an OS-managed application is a single uniform space from 0x00000000 to 0xffffffff , the real memory space of the hardware is broken down into pieces with different functionalities and there are often large gaps that aren't actually attached to anything. The GBA memory space includes the read-only BIOS (16KB), fast working RAM (32KB), slow working RAM (256KB), memory belonging directly to the screen (98KB), and space reserved for the cartridge's ROM (32MB) and optionally either battery-backed SRAM (64KB) or flash (64KB, bankswitchable) for save storage. The working (that is, \"normal\") RAM is split into fast and slow regions not because the designers thought you would like slower RAM, but to balance the device's cost against performance. The variables which the game updates constantly should be squeezed into fast RAM, with the rest on the slow boat. Note A game cartridge can contain a \"mapper\" or \"bankswitch\" capability which connects and disconnects different chips on the cartridge board to the console's memory space dynamically. This allows the game to have more data than will fit by breaking it down into chunks that are never loaded at the same time. However, this was much more common in 8-bit and 16-bit games since 32-bit games have a much larger address space available even on systems (including the GBA) which only wire up part of it. You may be interested in my high-level overview of how mappers are used on the NES. It is therefore necessary to divide Emerald up into sections \u2013 the read-only code and data, the fast variables, the slow variables, and the save file \u2013 and explicitly instruct the compiler on what goes where in the final ROM. This is accomplished through linker scripts. It is fortunately not necessary to understand every detail of linker script syntax for our purposes. The scripts are found in ld_script.txt and the files it includes by name. Notice that there are two versions of the linker script in the repository: one which makes sure everything is placed exactly in the same spot they ended up in the original ROM ( ld_script.txt ), and one for modern compilers which will find any new modules you've added and not be too particular about the exact order ( ld_script_modern.txt ). The latter is useful if you are making substantial changes to the game. We are examining the exact-reproduction version so that what we see in the script will correlate exactly to what we see in the game's memory in a live debugger. In general, the ordering of different pieces of data within the same linking section is due to the order they were added to the code base or the alphabetical order of the original source filenames, and not because they must be in that specific order. The naming conventions used in linker scripts are extremely archaic and non-obvious: .text means executable code, .data means global or static variables (those which always have a persistent value) and .bss means transient variables that pop in and out of existence when their functions run. .rodata is read-only data which is, at least, actually what it sounds like.","title":"Overall Structure and Layout"},{"location":"layout/#memory-map-summary","text":"Read-Only BIOS ( 0x00000000 ) Boot logo routine Function for validating ROM header and starting game Generic utility functions Slow RAM ( 0x02000000 ) 112KB reserved for the heap (the memory you get from malloc ) variables of files manually listed as okay for slow RAM (largely high-level game state that does not rapidly change) Fast RAM ( 0x03000000 ) variables of files manually listed as needing fast RAM The stack for function-local variables is not explicitly listed in the linker script, but the game will set up the stack to point towards the end of fast RAM before calling main . It grows downwards, and it is the responsibility of the programmer to make sure functions can never chain so deeply that it will begin overwriting memory already in use. Graphics ( 0x05000000 ) current color palette Video RAM for rendering the screen OAM (Object Attribute Memory, that is, sprites) Read-Only Memory ( 0x08000000 ) ROM header crt0 , which does some housekeeping before main is called main more executable code in no special order Script data for the game event scripting engine more executable code data embedded in executable code (short strings, numerical constants, etc) songs even more code multiboot front sprites of each mon other graphics Flash Memory ( 0x0E000000 ) Not explicitly listed in linker scripts nor physically present in the ROM file, but two copies of the save game (so that if one is corrupt, the other might still be loadable) are kept here. Most emulators will dump it to a .sav file on your computer.","title":"Memory Map Summary"},{"location":"layout/#rom-header","text":"The header must always be at 0x08000000 exactly so the BIOS boot function knows where to find it. It contains the game's name ( POKEMON EMER ), its assigned ID code ( BPEE ) and its assigned publisher code ( 01 , which obviously stands for the most important publisher.) It also contains the address of the entry point which the BIOS should jump to after it's satisfied the cartridge is valid, and the CRC checksum that the BIOS will compare against after checksumming the cartridge itself to make that validity check. Since the CRC can only be calculated against a finished ROM, blank space is reserved during the compile process and a command-line utility is used to patch in the correct value at the end of compiling. You can see the reservation of space in the ROM for the header in rom_header.s , though it's not very exciting, and the patching happens in the Makefile . The header wastes 156 bytes on including the same corporate logo in every single cartridge of every single game for silly legal reasons. The game will not boot if the logo in the game does not exactly match the logo in the BIOS, and (or so the reasoning went) if you include a copy of the logo without buying a license to do so, then you are opening yourself up to being sued off the face of the earth. Everyone has ignored this for over twenty years. There is a second header, GFRomHeader , which is particular to this game engine. It enumerates where to find various information from the save file or about this particular version of the game so that a host application (such as Colosseum on GameCube) can safely extract them from the cartridge. It also serves as handy mini-documentation for what keyword to search to find many things you may have been curious about:","title":"ROM header"},{"location":"layout/#rom_header_gfc","text":"static const struct GFRomHeader sGFRomHeader = { .version = GAME_VERSION, .language = GAME_LANGUAGE, .gameName = \"pokemon emerald version\", .monFrontPics = gMonFrontPicTable, .monBackPics = gMonBackPicTable, .monNormalPalettes = gMonPaletteTable, .monShinyPalettes = gMonShinyPaletteTable, .monIcons = gMonIconTable, .monIconPaletteIds = gMonIconPaletteIndices, .monIconPalettes = gMonIconPaletteTable, .monSpeciesNames = gSpeciesNames, .moveNames = gMoveNames, .decorations = gDecorations, .flagsOffset = offsetof(struct SaveBlock1, flags), .varsOffset = offsetof(struct SaveBlock1, vars), .pokedexOffset = offsetof(struct SaveBlock2, pokedex), .seen1Offset = offsetof(struct SaveBlock1, seen1), .seen2Offset = offsetof(struct SaveBlock1, seen2), .pokedexVar = VAR_NATIONAL_DEX - VARS_START, .pokedexFlag = FLAG_RECEIVED_POKEDEX_FROM_BIRCH, .mysteryEventFlag = FLAG_SYS_MYSTERY_EVENT_ENABLE, .pokedexCount = NATIONAL_DEX_COUNT, .playerNameLength = PLAYER_NAME_LENGTH, .trainerNameLength = TRAINER_NAME_LENGTH, .pokemonNameLength1 = POKEMON_NAME_LENGTH, .pokemonNameLength2 = POKEMON_NAME_LENGTH, // Two of the below 12s are likely move/ability name length, given their presence in this header .unk5 = 12, .unk6 = 12, .unk7 = 6, .unk8 = 12, .unk9 = 6, .unk10 = 16, .unk11 = 18, .unk12 = 12, .unk13 = 15, .unk14 = 11, .unk15 = 1, .unk16 = 8, .unk17 = 12, .saveBlock2Size = sizeof(struct SaveBlock2), .saveBlock1Size = sizeof(struct SaveBlock1), .partyCountOffset = offsetof(struct SaveBlock1, playerPartyCount), .partyOffset = offsetof(struct SaveBlock1, playerParty), .warpFlagsOffset = offsetof(struct SaveBlock2, specialSaveWarpFlags), .trainerIdOffset = offsetof(struct SaveBlock2, playerTrainerId), .playerNameOffset = offsetof(struct SaveBlock2, playerName), .playerGenderOffset = offsetof(struct SaveBlock2, playerGender), .frontierStatusOffset = offsetof(struct SaveBlock2, frontier.challengeStatus), .frontierStatusOffset2 = offsetof(struct SaveBlock2, frontier.challengeStatus), .externalEventFlagsOffset = offsetof(struct SaveBlock1, externalEventFlags), .externalEventDataOffset = offsetof(struct SaveBlock1, externalEventData), .unk18 = 0x00000000, .speciesInfo = gSpeciesInfo, .abilityNames = gAbilityNames, .abilityDescriptions = gAbilityDescriptionPointers, .items = gItems, .moves = gBattleMoves, .ballGfx = gBallSpriteSheets, .ballPalettes = gBallSpritePalettes, .gcnLinkFlagsOffset = offsetof(struct SaveBlock2, gcnLinkFlags), .gameClearFlag = FLAG_SYS_GAME_CLEAR, .ribbonFlag = FLAG_SYS_RIBBON_GET, .bagCountItems = BAG_ITEMS_COUNT, .bagCountKeyItems = BAG_KEYITEMS_COUNT, .bagCountPokeballs = BAG_POKEBALLS_COUNT, .bagCountTMHMs = BAG_TMHM_COUNT, .bagCountBerries = BAG_BERRIES_COUNT, .pcItemsCount = PC_ITEMS_COUNT, .pcItemsOffset = offsetof(struct SaveBlock1, pcItems), .giftRibbonsOffset = offsetof(struct SaveBlock1, giftRibbons), .enigmaBerryOffset = offsetof(struct SaveBlock1, enigmaBerry), .enigmaBerrySize = sizeof(struct EnigmaBerry), .moveDescriptions = NULL, .unk20 = 0x00000000, // 0xFFFFFFFF in FRLG }; It is very curious that the game name is in all lower-case. The variables marked as \"unknown\" in the decomp have the following names in the original code: // unknowns 5-17 WAZA_NAME_SIZE, ITEM_NAME_SIZE, SEED_NAME_SIZE, SPEABI_NAME_SIZE, ZOKUSEI_NAME_SIZE, MAPNAME_WIDTH, MAPNAME_MAX, TRTYPE_NAME_SIZE, GOODS_NAME_SIZE, ZUKAN_TYPE_SIZE, EOM_SIZE, BTL_TR_NAME_SIZE, KAIWA_WORK_SIZE, // unknown 18 0 // unknown 20 static const u8 IndexNull[ 0x100 - sizeof(POKEMON_ROM_HEADER)] = {}; Unknown 18 will take its secrets to the end of time, it seems. It's in a set of interoperability flags, but no name or explanation is given. Unknown 20 is not actually part of the structure in the original source code, but simply follows after it. It seems to be intended as padding to fill out 256 bytes, but its existence is pointless as the structure is 344 bytes. The ancient compiler the original team was using must have decided that an array with a negative length actually has a length of one rather than throwing an error which would have brought it to their attention as no longer needed.","title":"rom_header_gf.c"}]}